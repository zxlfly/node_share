## api文件夹下为基础的api入门介绍，只有一小部分详细的可以看[文档](https://nodejs.org/)
很基础的api

## koa
实现一个简版的koa

## socker-im
一个简版聊天室

## http

## HTTP缓存机制
**web缓存**
常见的网页资源比如图片、css、js都不经常变化，如果每次都重新请求资源，就会浪费资源，也增加了页面加载时间，影响用户体验。
**解决方法**
- HTTP 1.0
  - **expires**是HTTP1.0中定义的缓存字段。强缓存
    - 服务器返回时在``Response Headers``中增加该字段表示过期时间``expires: Thu, 03 Jan 2019 11:43:04 GMT``
    - 当客户端再次请求该资源的时候，会把客户端时间与该时间戳进行对比,但是客户端时间是不可靠的。所以这个方法不太行
- HTTP1.1
  - **cache-control**和上面那个方法一样都是强缓存
  - **cache-control** 优先级更高
  - 该字段是一个时间长度，单位是秒，表示多少秒之后资源失效
  - 不依赖客户端时间
- 协商缓存
  - 上面的两种方法都会访问本地的缓存直接验证是否过期，如果没有过期，就返回200。
  - 如果设置了``no-cache``和``no-store``则本地缓存会被忽略，去请求服务器验证资源是否更新。如果没有更新就返回304使用本地缓存
  - ``last-modified & if-Modified-Since``这是一组通过协商修改时间为基础的策略
    - 静态资源应答都会通过``last-modified``来标记修改时间
    - 下次请求会将``last-modified``时间作为``if-Modified-Since``字段放在请求报文中，用来询问服务器是否过期
      - 过期直接返回200和资源
      - 如果为过期则返回304
  - ``etag & if-None-Match``这种方法是通过内容来判断
    - 在初次加载的时候会吧内容的摘要hash返回``etag``
    - 下次请求相同资源会带上``etag``作为``if-None-Match``字段放在请求报文中询问服务器是否过期
      - 过期直接返回200和资源
      - 如果为过期则返回304


## mysql
建议安装最新的稳定版本，网上有很详细的教程  
基础的mysql示例  
sequelize-->orm  
## mongodb
建议安装最新的稳定版本，网上有很详细的教程  
helloword.js基础使用实例
example为一个简单的示例  
EventEmitter.js-->发布订阅，在上面的示例中使用到了

## mongoose
可以说就提供了模型这个功能，其他的和原来一样  

一个项目三要素：管理-开发方法-技术框架  
传统sql=>er(核心)=>db=>code先做一个实例关系图，然后建表再写程序
加入数据库ORM时对开发造成的影响  
使用sequelize变动的是开发方法  
sequelize=>code model 模型映射=>db(持久化服务)=>先在code里建立模型以及模型映射(核心)，根据模型映射为中心向两端发展，映射出db，模型代码生成对应的code api CRUD 再生成ui。这种方式所有的东西都在代码里，不需要了解数据库的实现原理  
在一些简单或者需要快速开发的项目来说中间价更方便，不需要sql
## restful
定义模型时候自动生成CRUD接口
- 反向工程 代码生成器
- 动态编程
  - 根据文件夹自动加载模块
  - 自动生成路由（注册通配路由）
## 鉴权 
cookie-session  
token  
jwt  

## 哈希算法
- 明文-密文 一一对应
- 雪崩效应-明文小幅变化密文剧烈变化
- 密文-明文无法反推
- 密文固定长度md5 sha1 sha256

## redis

## egg
前置知识需要了解egg的用法  
实现的技术特点就是科⾥化

## ts(typescript)
搭建Node TS开发环境  
ts实现装饰器和方法  
基于装饰器的RouterValidation Models 
>装饰器模式允许像一个现有的对象添加新的功能，同事又不改变其结构。这种类型的设计模式属于结构型模式。它是作为现有类的一个包装
>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整的前提下，提供了额外的功能

## docker
基于Linux的高效、敏捷、轻量级的容器（轻量虚拟）方案。一次封装，到处执行
## I/O
- I/O的阻塞与非阻塞  
  - 阻塞模式的I/O会造成应用程序等待,直到I/O完成。
  - 非阻塞模式下应用程序的调用将可能在没有拿到真正数据时就立即返回了,为此应用程序需要多次调用才能确认I/O操作完全完成。
- I/O的同步与异步
  - 如果做阻塞I/O调用,应用程序等待调用的完成的过程就是一种同步状况。
  - 相反,I/O为非阻塞模式时,应用程序则是异步的。
